pub fn arrays() {
    // 설명
    // 여러 가지 원소값을 묶어 만드는 하나의 복합 데이터타입
    // 튜플과 달리 같은 데이터타입의 원소만 가질 수 있다.  
    // 고정된 길이를 갖는다.

    // 선언
    // 대괄호로 원소값들을 묶으며, 원소값 간에는 쉼표로 구분한다.  
    let arr = [1, 2, 3, 4, 5];
    println!("{:?}", arr);

    // 동일한 데이터타입의 원소만 가질 수 있다.  
    // 데이터타입을 선언해 사용할 때에는 대괄호 안에 데이터타입과 원소 개수를 선언하며
    // 데이터타입과 원소 개수는 세미콜론(;)으로 구분한다.  
    let arr: [u8; 5] = [1, 2, 3, 4, 5];
    println!("{:?}", arr);

    // 동일한 값을 n 개 가지는 배열은 아래와 같이 쉽게 선언할 수 있다.  
    let arr = [3; 5];
    println!("{:?}", arr);

    let arr = [5, 5, 5, 5, 5];
    println!("{:?}", arr);

    // 배열 원소에 접근할 때에는 대괄호 안에 인덱스 번호를 입력하는 bracket syntax를 사용한다.
    let arr: [u8; 5] = [1, 2, 3, 4, 5];
    println!("{:?}", arr[0] + arr[4]);

    // 다수의 원소에 접근할 때 슬라이싱을 이용할 수 있다.  
    // 슬라이싱은 인덱스 번호 사이에 .. 을 써넣는 방식으로 표기한다.
    let arr: [u8; 5] = [1, 2, 3, 4, 5];
    println!("{:?}", &arr[0..3]);
    println!("{:?}", &arr[2..]);
    println!("{:?}", &arr[..2]);

    // 유효 범위를 벗어난 원소 접근은 런타임 패닉을 발생시킨다.  
    let arr: [u8; 5] = [1, 2, 3, 4, 5];
    println!("{:?}", &arr[7]);
    // >> index out of bounds: the length is 5 but the index is 7
}