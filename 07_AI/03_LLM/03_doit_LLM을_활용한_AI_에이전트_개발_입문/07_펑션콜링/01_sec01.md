
## 펑션 콜링  

### 정의  

- GPT에게 특정한 기능을 가진 함수와 그에 대한 설명을 제공하고, 상황에 맞게 그 함수를 호출하도록 하는 방법  
- GPT는 텍스트 생성 모델이며, 특정한 기능을 수행하거나 실시간 정보를 알 수 없다는 한계를 극복하기 위한 방법  

### 구성 요소  

#### 아키텍처적 구성 요소  



#### 코드적 구성 요소  

- 도구 목록 : GPT 모델이 어떤 도구를 사용할 수 있는지 알려주는 설명서 역할.  
- 도구 함수 : 실제로 어떠한 기능을 수행하는 함수  

```python
# 도구 함수
def get_current_time():
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(now)
    return now

# 도구 목록
tools = [
    {
        "type": "function",
        "function": {
            "name": "get_current_time",
            "description": "현재 날짜와 시간을 반환합니다."
        }
    },
    # 추가로 정의되는 도구들을 추가한다.  
]
```


### 펑션 콜링 작동 방법  

#### OpenAI API  

- 펑션 콜링에 사용할 수 있는 도구 목록을 딕셔너리 형태로 정의해두고  
- GPT API 를 호출할 때 이 도구 목록을 함께 제공한다.  
- GPT는 답변에 특정 기능이 필요하다고 판단할 경우, 정의된 도구 목록에서 그 기능을 수행할 수 있는 도구가 있는지 찾고  
- 도구가 있다면 그 도구를 사용해 답변을 수행한다.  


### 실습  

#### 현재 시간을 알려주는 도구  

> gpt api 요청 등의 내용은 생략  

- gpt_functions.py 파일의 get_current_time 함수  

```python
# gpt_functions.py
from datetime import datetime

def get_current_time():
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(now)
    return now

tools = [
    {
        "type": "function",
        "function": {
            "name": "get_current_time",
            "description": "현재 날짜와 시간을 반환합니다."
        }
    },
]
```

- 터미널에서 툴콜링을 테스트하는 코드

```python
# what_time_is_it_terminal.py
from tools.gpt_functions import get_current_time, tools
from openai import OpenAI
from config.config import config

client = OpenAI(api_key = config["apikey"]["openai"])

# chat gpt로부터 응답을 받아오는 기본적인 틀
def get_ai_response(messages, tools=None):
    response = client.chat.completions.create(
        model = "gpt-4o",
        messages = messages,
        tools = tools
    )
    return response

# 기본 초기 메시지 셋
messages = [
    {"role" : "system", "content" : "너는 사용자를 도와주는 상담사야."},
]

# 터미널 대화 섹션
def terminal_conversation():
    while True:
        # 사용자 입력 발화
        user_input = input("사용자\t:")
        if user_input == "exit":
            break
        
        # 메시지 셋에 사용자 발화 입력
        messages.append({"role":"user", "content":user_input})
        
        # chat gpt에거 답변 받아옴
        ai_response = get_ai_response(messages=messages,
                                    tools=tools) # 사용 가능한 도구 목록 제공
        ai_message = ai_response.choices[0].message
        print(ai_message) #---------------------------------------------------- (1)
        
        # tool_calls
        tool_calls = ai_message.tool_calls
        # gpt가 특정 함수 실행이 필요하다고 판단할 경우, 응답의 tool_calls 속성에 정보가 포함됨 #TODO: 메시지 구조 확인
        if tool_calls:
            # 도구 정보 추출 #TODO: tool_calls 리스폰스 구조 확인
            tool_name = tool_calls[0].function.name
            tool_call_id = tool_calls[0].id #TODO: id가 무슨 역할을 하는지 확인하고 스터디때 발표
            # 도구마다 사용 함수 매칭해서 도구의 결과를 메시지로 생성
            if tool_name == "get_current_time":
                messages.append(
                    {
                        "role" : "function",
                        "tool_call_id" : tool_call_id,  # 여기에 id를 입력해 gpt 자신이 요청한 도구 호출과 결과물을 매칭
                        "name" : tool_name,
                        "content" : get_current_time(), # 함수의 결과물을 입력으로 적재
                    }
                )
            # 한번 더 gpt 응답 호출, 이번엔 도구의 결과와 도구 호출 id를 포함함
            print(messages) #-------------------------------------------------- (2)
            ai_response = get_ai_response(messages, tools=tools)
            print(ai_response) #----------------------------------------------- (3)
            ai_message = ai_response.choices[0].message
            
        messages.append(ai_message)
        print("AI\t:" + ai_message.content)
```

- 대화 내용  

```bash
사용자   :안녕하세요. 지금은 몇시인가요?
AI      :안녕하세요! 지금 시간은 2026년 1월 26일 12시 33분입니다. 무엇을 도와드릴까요?
```

- 요청 및 응답 사항 뜯어보기  

```python
# (1) 최초 AI 응답 ai_message
ChatCompletionMessage(
    content=None, refusal=None, role='assistant', annotations=[], audio=None, function_call=None,
    tool_calls=[
        ChatCompletionMessageFunctionToolCall(
            id='call_AYhSDEAD2en5ek8egrkFGLE3', # Tool Call ID
            function=Function(
                arguments='{}', name='get_current_time'),
            type='function')
            ]
        )

# (2) Tool 의 결과물을 담은 messages
[
    {'role': 'system', 'content': '너는 사용자를 도와주는 상담사야.'},
    {'role': 'user', 'content': '안녕하세요. 지금은 몇시인가요?'},
    {'role': 'function', 'tool_call_id': 'call_15...', 'name': 'get_current_time', 'content': '2026-01-26 12:36:41'}
]

# (3) 최종 응답 ai_response
ChatCompletion(id='chatcmpl-D27h4yWyDUX5LU8pELCn3idll5RNN',
    choices=[
        Choice(finish_reason='stop',
               index=0,
               logprobs=None,
               message=ChatCompletionMessage(
                  content='안녕하세요! 현재 시간은 2026년 1월 26일 오후 12시 36분입니다.',
                  refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None
                )
              )
            ],
    created=1769398602,
    model='gpt-4o-2024-08-06',
    object='chat.completion',
    service_tier='default',
    system_fingerprint='fp_deacdd5f6f',
    usage=CompletionUsage(
        completion_tokens=26,
        prompt_tokens=78,
        total_tokens=104,
        completion_tokens_details=CompletionTokensDetails(
            accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0
        ),
        prompt_tokens_details=PromptTokensDetails(
            audio_tokens=0, cached_tokens=0
        )
    )
)
```

> - tool_calls[0].id  
> 
> tool_calls[0].id)는 **GPT가 요청한 특정 도구 호출과, 그 도구의 실행 결과를 1:1로 연결하기 위한 식별자(ID)**  
> **“GPT가 방금 요청한 함수 호출과, 내가 돌려준 결과가 같은 요청에 대한 응답임을 GPT에게 알려주는 연결 고리”**
> GPT는 한 번의 응답에서 **여러 개의 도구 호출(tool_calls)**을 요청할 수 있고, 따라서 “어떤 함수 요청에 대한 결과인지”를 명확히 구분해야 한다.  
> 
```python
tool_call_id = tool_calls[0].id #TODO: id가 무슨 역할을 하는지 확인하고 스터디때 발표
if tool_name == "get_current_time":
    messages.append(
        {
            "role" : "function",
            "tool_call_id" : tool_call_id,  # 여기에 id를 입력해 gpt 자신이 요청한 도구 호출과 결과물을 매칭
            "name" : tool_name,
            "content" : get_current_time(),
        }
    )
```
> 

#### API 호출 횟수  

- 이렇게 펑션 콜링을 하는 경우, API 호출의 횟수는 총 2회이다.  
- 확인 필요  

```python
 # 메시지 셋에 사용자 발화 입력
messages.append({"role":"user", "content":user_input})
# chat gpt에거 답변 받아옴
ai_response = get_ai_response(messages=messages,tools=tools) #--- 1회

...

# 펑션콜링에 대한 결과값을 담아 한 번 더 LLM API 요청
if tool_name == "get_current_time":
    messages.append(
        {
            "role" : "function",
            "tool_call_id" : tool_call_id,
            "name" : tool_name,
            "content" : get_current_time(),
        }
    )
ai_response = get_ai_response(messages, tools=tools) #---------- 2회
```

#### 도시별 시간 알려 주기  

- 책에서는 아래와 같이, get_current_time() 함수만으로는 다른 도시의 시간을 아는 게 어렵다고 예시를 들었다.  
- LLM 모델이 get_current_time() 의 결과물 시간을 UTC 기준으로 알아듣기 때문이라고.  

```bash
사용자: 지금 뉴욕은 몇 시야?
2025-01-06 19:09:24
AI: 현재 UTC 시간은 2025년 1월 6일 19시 9분 24초 입니다. 뉴욕은 동부 표준시(EST) 를 사용하므로, UTC 시간보다 5시간 늦습니다. 따라서 뉴욕의 현재 시간은 2025년 1월 6일 14시 9분 24초입니다.
```

- 하지만 현재 기준(2026-01-26)으로는 LLM이 사용자의 위치를 알고, 이에 대비해 뉴욕 시간을 계산한다.  

```bash
사용자   : 지금 뉴욕은 몇 시야?
2026-01-26 12:48:34
AI      :현재 한국 시간은 2026년 1월 26일 오후 12시 48분입니다. 뉴욕은 동부 표준시(EST)를 사용하고 있으며, 한국과 뉴욕의 시차는 일반적으로 14시간입니다. 따라서 뉴욕의 현재 시간은 1월 26일 오전 12시 48분일 것입니다.
```

- 하지만 틀렸다. 한국과 뉴욕의 시차까지는 맞췄지만  
- 계산이 틀렸다. 14시간 차이면 1월 25일 밤 10시 48분으로 답변해야 하는데, 26일 오전 12시 48분 즉, 12시간차로 계산해서 오답을 냈다.  
- 이러나 저러나 세계시각을 알 수 있게 문맥을 제공해야 한다.  

![alt text](assets/images/newyork_time.png)  

- 도시별 시간을 알려주기 위해 `pytz` 라이브러리를 사용한다.  
- 이 라이브러리는 타임존 문자열을 받아 그에 해당하는 타임존 인스턴스를 생성한다.  
- 이를 datetime.now() 에 넣으면 해당 타임존의 시각을 구할 수 있다.  
- 이를 위해 일전에 작성했던 gpt_function.py 파일을 수정한다.  

```python
def get_current_time(timezone="Asia/Seoul"): # timezone 변수(str)를 받음
    tz = pytz.timezone(timezone) # 타임존 인스턴스 생성
    now = datetime.now(tz).strftime("%Y-%m-%d %H:%M:%S") # 타임존 인스턴스를 인자로 넣어 now 획득
    now_timezone = f"{now} {timezone}"
    print(now_timezone)
    return now_timezone

tools = [
    {
        "type": "function",
        "function": {
            "name": "get_current_time",
            "description": "해당 타임존의 날짜와 시간을 반환합니다.",
            "parameters": {
                "type":"object",
                "properties":{
                    "timezone": {
                        "type":"string",
                        "description":"현재 날짜와 시간을 반환할 타임존을 입력하세요.(예. Aisa/Seoul)",
                    }
                },
                "required":["timezone"]
            }
        }
    },
]
```

[pytz - https://whdrns2013.github.io/python/20260126_001_pytz](https://whdrns2013.github.io/python/20260126_001_pytz)


- 그리고 이에 맞춰 terminal 코드도 변경해준다,  

```python
# what_time_is_it_terminal.py
from tools.gpt_functions import get_current_time, tools
from openai import OpenAI
from config.config import config
import json

client = OpenAI(api_key = config["apikey"]["openai"])

# chat gpt로부터 응답을 받아오는 기본적인 틀
def get_ai_response(messages, tools=None):
    response = client.chat.completions.create(
        model = "gpt-4o",
        messages = messages,
        tools = tools
    )
    return response

# 기본 초기 메시지 셋
messages = [
    {"role" : "system", "content" : "너는 사용자를 도와주는 상담사야."},
]

# 터미널 대화 섹션
def terminal_conversation():
    while True:
        # 사용자 입력 발화
        user_input = input("사용자\t:")
        if user_input == "exit":
            break
        
        # 메시지 셋에 사용자 발화 입력
        messages.append({"role":"user", "content":user_input})
        
        # chat gpt에거 답변 받아옴
        ai_response = get_ai_response(messages=messages,
                                    tools=tools)
        ai_message = ai_response.choices[0].message
        
        # tool_calls
        tool_calls = ai_message.tool_calls
        if tool_calls:
            # 도구 정보 추출
            tool_name = tool_calls[0].function.name
            tool_call_id = tool_calls[0].id
            
            arguments = json.loads(tool_calls[0].function.arguments) # ----- (1) tool call 에서 주는 파라미터를 받아서
            
            # 도구마다 사용 함수 매칭해서 도구의 결과를 메시지로 생성
            if tool_name == "get_current_time":
                messages.append(
                    {
                        "role" : "function",
                        "tool_call_id" : tool_call_id,
                        "name" : tool_name,
                        "content" : get_current_time(timezone=arguments["timezone"]), # ---- (2) function의 파라미터로 넣음
                    }
                )
            # 한번 더 gpt 응답 호출, 이번엔 도구의 결과와 도구 호출 id를 포함함
            ai_response = get_ai_response(messages, tools=tools)
            ai_message = ai_response.choices[0].message
            
        messages.append(ai_message)
        print("AI\t:" + ai_message.content)
```

- 대화를 진행해보면  

```bash
사용자  :지금 몇시야?
AI      :어느 나라나 지역의 시간을 알고 싶으신가요? 예를 들어 "Asia/Seoul"과 같은 형태로 말씀해 주세요.
사용자  :서울
AI      :지금 서울의 시간은 2026년 1월 27일 오후 9시 37분입니다.
사용자  :미뉴뉴욕은?
AI      :뉴욕의 시간은 2026년 1월 27일 오전 7시 38분입니다.
```

#### 여러 도시의 시간 알려주기  

- 위까지 구축한 것에 여러 도시 물어보기  

```bash
사용자  :서울, 도쿄, 뉴욕의 시간은 몇시야?
Traceback (most recent call last):
    print("AI\t:" + ai_message.content)
          ~~~~~~~~^~~~~~~~~~~~~~~~~~~~
TypeError: can only concatenate str (not "NoneType") to str
```

- 마지막 AI 의 답변을 뜯어보니  

```bash
# 첫 function call 은 잘 들어옴 (서울)
Function(arguments='{"timezone": "Asia/Seoul"}', name='get_current_time')

# function call 을 한 뒤, 답변을 하는 게 아닌 "다음 시간대 지역 시간 펑션콜"을 함
# 그러니 여기서 답변을 찾을 수가 없지..
ChatCompletionMessage(content=None,...
   function=Function(arguments='{"timezone": "Asia/Seoul"}', name='get_current_time'), type='function'...
   function=Function(arguments='{"timezone": "Asia/Tokyo"}', name='get_current_time'), type='function'...
   function=Function(arguments='{"timezone": "America/New_York"}', name='get_current_time'),...
```

- 여러 함수가 순차적으로 호출될 수 있도록 코드를 수정  

```python
# what_time_is_it_terminal.py
from tools.gpt_functions import get_current_time, tools
from openai import OpenAI
from config.config import config
import json

client = OpenAI(api_key = config["apikey"]["openai"])

# chat gpt로부터 응답을 받아오는 기본적인 틀
def get_ai_response(messages, tools=None):
    response = client.chat.completions.create(
        model = "gpt-4o",
        messages = messages,
        tools = tools
    )
    return response

# 기본 초기 메시지 셋
messages = [
    {"role" : "system", "content" : "너는 사용자를 도와주는 상담사야."},
]

# 터미널 대화 섹션
def terminal_conversation():
    while True:
        # 사용자 입력 발화
        user_input = input("사용자\t:")
        if user_input == "exit":
            break
        
        # 메시지 셋에 사용자 발화 입력
        messages.append({"role":"user", "content":user_input})
        
        # chat gpt에거 답변 받아옴
        ai_response = get_ai_response(messages=messages,
                                    tools=tools)
        ai_message = ai_response.choices[0].message
        
        # tool_calls
        tool_calls = ai_message.tool_calls
        if tool_calls:
            for tool_call in tool_calls: # ---- (1) tool call 마다 반복
                # 도구 정보 추출
                tool_name = tool_call.function.name
                tool_call_id = tool_call.id
                
                print(tool_call.function)
                arguments = json.loads(tool_call.function.arguments) 
                
                # 도구마다 사용 함수 매칭해서 도구의 결과를 메시지로 생성
                if tool_name == "get_current_time":
                    messages.append(
                        {
                            "role" : "function",
                            "tool_call_id" : tool_call_id,
                            "name" : tool_name,
                            "content" : get_current_time(timezone=arguments["timezone"]), 
                        }
                    )
            
            messages.append({"role":"system", "content":"이제 주어진 결과들을 바탕으로 답변하시오"}) # ------ (2) tool call 이 끝났으니, 답변하도록 함        
            # 한번 더 gpt 응답 호출, 이번엔 도구의 결과와 도구 호출 id를 포함함
            ai_response = get_ai_response(messages, tools=tools)
            ai_message = ai_response.choices[0].message
        print(ai_message)
        messages.append(ai_message)
        print("AI\t:" + ai_message.content)
```

- 질답을 해보면  

```bash
사용자  :서울, 도쿄, 뉴욕의 시간은  몇 시야?
AI      :현재 시각은 다음과 같습니다:

- 서울: 2026년 1월 27일 22시 7분 14초
- 도쿄: 2026년 1월 27일 22시 7분 14초
- 뉴욕: 2026년 1월 27일 8시 7분 14초

도쿄와 서울은 같은 시차이며, 뉴욕은 14시간 늦습니다.
```

#### 스트림릿에 적용  

